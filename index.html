<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Zero Point: Ranking Battle</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-tap-highlight-color: transparent; }
    body { font-family: system-ui, -apple-system, sans-serif; background-color: #1a2e1a; touch-action: manipulation; }
    
    @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-2px); } 75% { transform: translateX(2px); } }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes thinking { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
    
    /* Skill Effects */
    @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
    @keyframes lightning { 0% { opacity: 0; transform: scale(1); } 10% { opacity: 1; transform: scale(1.2); filter: brightness(2); } 30% { opacity: 1; transform: scale(1.1); } 100% { opacity: 0; transform: scale(1); } }
    @keyframes spin-in { 0% { transform: rotate(0deg) scale(0); opacity: 0; } 50% { transform: rotate(180deg) scale(1.5); opacity: 1; } 100% { transform: rotate(360deg) scale(0); opacity: 0; } }
    @keyframes shake-hard { 0%, 100% { transform: translate(0, 0) rotate(0deg); } 25% { transform: translate(-5px, 5px) rotate(-5deg); } 75% { transform: translate(-5px, -5px) rotate(-5deg); } }
    @keyframes stamp { 0% { transform: scale(2); opacity: 0; } 50% { transform: scale(1); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
    @keyframes roll { 0% { transform: rotate(0deg); } 100% { transform: rotate(720deg); } }

    .animate-pop { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .animate-shake { animation: shake 0.2s ease-in-out infinite; }
    .animate-blink { animation: blink 1s infinite; }
    .animate-thinking { animation: thinking 1s infinite; }
    
    .effect-float { animation: floatUp 1s forwards; }
    .effect-lightning { animation: lightning 0.6s ease-out forwards; }
    .effect-spin { animation: spin-in 0.8s ease-in-out forwards; }
    .effect-shake-hard { animation: shake-hard 0.5s ease-in-out infinite; }
    .effect-stamp { animation: stamp 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    .effect-roll { animation: roll 0.8s ease-in-out forwards; }

    .custom-scroll::-webkit-scrollbar { width: 4px; }
    .custom-scroll::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
    .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const firebaseConfig = {
      apiKey: "AIzaSyBYV5nAO4sswR9prt88trv2u1L_f_kCyaU",
      authDomain: "zero-9c4b4.firebaseapp.com",
      projectId: "zero-9c4b4",
      storageBucket: "zero-9c4b4.firebasestorage.app",
      messagingSenderId: "1009247488012",
      appId: "1:1009247488012:web:c11f59dce6b5aef9d38629",
      measurementId: "G-C1329R3S78"
    };

    let db;
    try {
      if (firebaseConfig.projectId) {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
      }
    } catch (e) {
      console.error("Firebase Connection Failed:", e);
    }

    const { useState, useEffect, useRef } = React;

    const Icons = {
      Shuffle: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.7-1.1 2-1.7 3.3-1.7H22"/><path d="m18 2 4 4-4 4"/><path d="M2 6h1.9c1.5 0 2.9.9 3.6 2.2"/><path d="M22 18h-5.9c-1.3 0-2.6-.7-3.3-1.8l-.5-.8"/><path d="m18 14 4 4-4 4"/></svg>,
      RotateCcw: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
      Plus: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12h14"/><path d="M12 5v14"/></svg>,
      Minus: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12h14"/></svg>,
      Zap: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
      Ban: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></svg>,
      Trophy: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>,
      Eye: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>,
      EyeOff: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7c.44 0 .87-.03 1.28-.08"/><line x1="2" y1="2" x2="22" y2="22"/></svg>,
      BookOpen: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
    };

    const ZeroPointGame = () => {
      const MAX_ROUNDS = 5;

      const [gameState, setGameState] = useState('start');
      const [playerHand, setPlayerHand] = useState([]);
      const [aiHand, setAiHand] = useState([]);
      const [playerCard, setPlayerCard] = useState(null);
      const [aiCard, setAiCard] = useState(null);
      
      const originalPlayerCardRef = useRef(null);
      const originalAiCardRef = useRef(null);

      const [playerScore, setPlayerScore] = useState(0);
      const [aiScore, setAiScore] = useState(0);
      const [round, setRound] = useState(1);
      const [message, setMessage] = useState('');
      const [playerSkills, setPlayerSkills] = useState([]);
      const [aiSkills, setAiSkills] = useState([]);
      
      const aiSkillsRef = useRef([]);

      const [skillLog, setSkillLog] = useState([]);
      const [nullifyMode, setNullifyMode] = useState(false);
      const [turnPhase, setTurnPhase] = useState('select');
      const [resultType, setResultType] = useState(null);
      const [showAiSkills, setShowAiSkills] = useState(false);
      const [aiThinking, setAiThinking] = useState(false);
      const [activeEffects, setActiveEffects] = useState([]);
      const [aiRetrievePending, setAiRetrievePending] = useState(false);
      
      const [leaderboard, setLeaderboard] = useState([]);
      const [showLeaderboard, setShowLeaderboard] = useState(false);
      const [showRules, setShowRules] = useState(false);
      const [playerName, setPlayerName] = useState('');
      const [isSubmitting, setIsSubmitting] = useState(false);
      
      const [aiPattern, setAiPattern] = useState({ totalMoves: 0, lowPref: 0, midPref: 0, highPref: 0, earlyLow: 0, earlyHigh: 0, lateLow: 0, lateHigh: 0 });

      // [BUG FIX] ì•ˆì „ì¥ì¹˜: AI ìƒê° ì¤‘ ê°•ì œ í•´ì œ íƒ€ì´ë¨¸
      useEffect(() => {
        let timer;
        if (aiThinking) {
          timer = setTimeout(() => {
            if (aiThinking) {
              console.warn("AI thinking timeout force release");
              setAiThinking(false);
              setMessage("AI ì‘ë‹µ ì‹œê°„ ì´ˆê³¼ - í„´ ì§„í–‰");
            }
          }, 5000); // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
        }
        return () => clearTimeout(timer);
      }, [aiThinking]);

      const skillTypes = [
        { id: 'retrieve', name: 'íšŒìˆ˜', icon: 'RotateCcw', desc: 'ë°©ê¸ˆ ë‚¸ ì¹´ë“œë¥¼ ì†íŒ¨ë¡œ íšŒìˆ˜í•©ë‹ˆë‹¤.', color: 'bg-blue-600' },
        { id: 'opp-plus', name: 'ìƒëŒ€+1', icon: 'Plus', desc: 'ìƒëŒ€ ì¹´ë“œì˜ ìˆ«ìë¥¼ 1 ì˜¬ë¦½ë‹ˆë‹¤. (10â†’0)', color: 'bg-red-600' },
        { id: 'opp-minus', name: 'ìƒëŒ€-1', icon: 'Minus', desc: 'ìƒëŒ€ ì¹´ë“œì˜ ìˆ«ìë¥¼ 1 ë‚´ë¦½ë‹ˆë‹¤. (0â†’10)', color: 'bg-red-500' },
        { id: 'self-plus', name: 'ë³¸ì¸+1', icon: 'Plus', desc: 'ë³¸ì¸ ì¹´ë“œì˜ ìˆ«ìë¥¼ 1 ì˜¬ë¦½ë‹ˆë‹¤. (10â†’0)', color: 'bg-green-600' },
        { id: 'self-minus', name: 'ë³¸ì¸-1', icon: 'Minus', desc: 'ë³¸ì¸ ì¹´ë“œì˜ ìˆ«ìë¥¼ 1 ë‚´ë¦½ë‹ˆë‹¤. (0â†’10)', color: 'bg-green-500' },
        { id: 'double', name: '2ë°°', icon: 'Zap', desc: 'ë³¸ì¸ ì¹´ë“œë¥¼ 2ë°°ë¡œ ë§Œë“­ë‹ˆë‹¤. (10 ì´ˆê³¼ ì‹œ ì¼ì˜ ìë¦¬ë§Œ ì ìš©)', color: 'bg-yellow-600' },
        { id: 'random', name: 'ëœë¤', icon: 'Shuffle', desc: 'ë³¸ì¸ ì¹´ë“œë¥¼ 0~10 ì¤‘ ëœë¤ìœ¼ë¡œ ë³€ê²½í•©ë‹ˆë‹¤.', color: 'bg-purple-600' },
        { id: 'nullify', name: 'ë¬´ë ¥í™”', icon: 'Ban', desc: 'ì´ë¯¸ ì‚¬ìš©ëœ ìŠ¤í‚¬ íš¨ê³¼ë¥¼ 1ê°œ ì·¨ì†Œí•©ë‹ˆë‹¤.', color: 'bg-gray-700' }
      ];

      const getRandomSkill = () => {
        const skill = skillTypes[Math.floor(Math.random() * skillTypes.length)];
        return { ...skill, uniqueId: Date.now() + Math.random() };
      };

      const fetchLeaderboard = async () => {
        if (!db) return;
        try {
          const snapshot = await db.collection('scores').orderBy('score', 'desc').limit(10).get();
          const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          setLeaderboard(data);
        } catch (error) {
          console.error("Error fetching leaderboard:", error);
        }
      };

      const submitScore = async () => {
        if (!db || !playerName.trim()) return;
        if (playerScore < 0 || playerScore > 50) return alert("ì˜¤ë¥˜: ë¹„ì •ìƒ ì ìˆ˜");
        if (playerName.length > 10) return alert("ì´ë¦„ì€ 10ê¸€ì ì´ë‚´");

        setIsSubmitting(true);
        try {
          await db.collection('scores').add({
            name: playerName.trim(),
            score: playerScore,
            date: new Date(),
            aiLevel: 'Normal'
          });
          await fetchLeaderboard();
          setIsSubmitting(false);
          setGameState('start');
          setShowLeaderboard(true);
        } catch (error) {
          console.error("Error saving score:", error);
          if (error.code === 'permission-denied') {
             alert("ë³´ì•ˆ ê²½ê³ : ì ìˆ˜ ì €ì¥ ì‹¤íŒ¨ (ê·œì¹™ ìœ„ë°˜)");
          } else {
             alert("ì ìˆ˜ ì €ì¥ ì‹¤íŒ¨: " + error.message);
          }
          setIsSubmitting(false);
        }
      };

      useEffect(() => { if(showLeaderboard) fetchLeaderboard(); }, [showLeaderboard]);

      const updateAiSkills = (newSkills) => {
        setAiSkills(newSkills);
        aiSkillsRef.current = newSkills;
      };

      const initGame = () => {
        const deck = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        setPlayerHand([...deck]);
        setAiHand([...deck]);
        setPlayerCard(null);
        setAiCard(null);
        originalPlayerCardRef.current = null;
        originalAiCardRef.current = null;
        setGameState('playing');
        setTurnPhase('select');
        setMessage('ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”');
        setSkillLog([]);
        setResultType(null);
        setShowAiSkills(false);
        setAiThinking(false);
        setActiveEffects([]);
        setAiRetrievePending(false);
      };

      const resetCampaign = () => {
        setRound(1);
        setPlayerScore(0);
        setAiScore(0);
        setPlayerSkills([]);
        setAiSkills([]);
        updateAiSkills([]); 
        initGame();
        grantRoundSkills(1);
      };

      const grantRoundSkills = (roundNum) => {
        const newPlayerSkills = Array(roundNum).fill(null).map(() => getRandomSkill());
        const newAiSkills = Array(roundNum).fill(null).map(() => getRandomSkill());
        setPlayerSkills(prev => [...prev, ...newPlayerSkills]);
        const updatedAiSkills = [...aiSkillsRef.current, ...newAiSkills];
        updateAiSkills(updatedAiSkills);
      };

      const triggerEffect = (skillId, target) => {
        const id = Date.now() + Math.random();
        setActiveEffects(prev => [...prev, { id, skillId, target }]);
        setTimeout(() => {
          setActiveEffects(prev => prev.filter(e => e.id !== id));
        }, 1000);
      };

      const learnPattern = (card, handSize) => {
        setAiPattern(prev => {
          const newPattern = { ...prev };
          newPattern.totalMoves++;
          if (card <= 3) newPattern.lowPref++; else if (card <= 6) newPattern.midPref++; else newPattern.highPref++;
          if (handSize > 6) { if (card <= 4) newPattern.earlyLow++; else newPattern.earlyHigh++; } 
          else { if (card <= 4) newPattern.lateLow++; else newPattern.lateHigh++; }
          return newPattern;
        });
      };

      const aiSelectCard = (hand) => {
        if (!hand || hand.length === 0) return null;
        const p = aiPattern;
        let candidates = [...hand];
        if (p.totalMoves < 5) return candidates[Math.floor(Math.random() * candidates.length)];
        if (hand.length <= 5 && p.lateHigh > p.lateLow) {
             const lowCards = hand.filter(c => c <= 4);
             if (lowCards.length > 0) candidates = lowCards;
        }
        return candidates[Math.floor(Math.random() * candidates.length)];
      };

      const applySkillValue = (baseValue, skillId, storedValue) => {
        if (baseValue === null || baseValue === undefined) return baseValue;
        let val = Number(baseValue);
        if (isNaN(val)) return baseValue;

        switch(skillId) {
          case 'opp-plus': case 'self-plus': return val + 1 > 10 ? 0 : val + 1; 
          case 'opp-minus': case 'self-minus': return val - 1 < 0 ? 10 : val - 1; 
          case 'double': 
            let doubled = Math.floor(val) * 2;
            return doubled > 10 ? doubled % 10 : doubled;
          case 'random': 
            if (storedValue !== undefined) return storedValue;
            return val; 
          default: return val;
        }
      };

      const calculateCurrentValues = (currentLog) => {
        let pCard = originalPlayerCardRef.current;
        let aCard = originalAiCardRef.current;

        currentLog.filter(l => !l.nullified).forEach(log => {
          if (log.skillId === 'retrieve') return; 
          if (log.target === 'player') pCard = applySkillValue(pCard, log.skillId, log.storedValue);
          else if (log.target === 'ai') aCard = applySkillValue(aCard, log.skillId, log.storedValue);
        });
        return { pCard, aCard };
      };

      const getWinner = (p, a) => {
        if (p === a) return 'draw';
        if (p === 10 && a === 0) return 'player-win';
        if (a === 10 && p === 0) return 'ai-win';
        return p < a ? 'player-win' : 'ai-win';
      };

      const aiRespond = (currentLogState, currentAiSkills) => {
        if (currentAiSkills.length === 0) {
          setAiThinking(false);
          setMessage('ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ê±°ë‚˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”');
          return;
        }

        const { pCard, aCard } = calculateCurrentValues(currentLogState);
        const currentResult = getWinner(pCard, aCard);

        if (currentResult === 'ai-win') {
          setAiThinking(false);
          setMessage('ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ê±°ë‚˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”');
          return;
        }

        let bestSkill = null;
        let bestRandomVal = undefined;

        const combatSkills = currentAiSkills.filter(s => !['nullify', 'retrieve', 'random'].includes(s.id));
        
        for (const s of combatSkills) {
          let tempP = pCard;
          let tempA = aCard;
          if (s.id.startsWith('opp-')) tempP = applySkillValue(tempP, s.id);
          else tempA = applySkillValue(tempA, s.id);
          
          const res = getWinner(tempP, tempA);
          if (res === 'ai-win' || (res === 'draw' && currentResult === 'player-win')) {
            bestSkill = s;
            break;
          }
        }

        if (!bestSkill && currentResult === 'player-win') {
          const randomSkill = currentAiSkills.find(s => s.id === 'random');
          if (randomSkill) {
            const rnd = Math.floor(Math.random() * 11);
            const res = getWinner(pCard, rnd);
            if (res === 'ai-win' || res === 'draw') {
              bestSkill = randomSkill;
              bestRandomVal = rnd;
            }
          }
        }

        if (!bestSkill && currentResult === 'player-win') {
          const retrieveSkill = currentAiSkills.find(s => s.id === 'retrieve');
          if (retrieveSkill) {
             const newLog = { 
               id: Date.now() + Math.random(), 
               user: 'AI', 
               skill: retrieveSkill, 
               skillId: 'retrieve', 
               target: 'ai', 
               nullified: false 
             };
             
             const nextLogs = [...currentLogState, newLog];
             setSkillLog(nextLogs);
             
             // [FIX] Update Ref immediately
             const nextSkills = currentAiSkills.filter(s => s.uniqueId !== retrieveSkill.uniqueId);
             updateAiSkills(nextSkills);
             
             triggerEffect('retrieve', 'ai');
             setMessage('AIê°€ íšŒìˆ˜ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤! (ë¬´ë ¥í™” ê°€ëŠ¥)');
             setAiRetrievePending(true);
             setAiThinking(false);
             return;
          }
        }

        if (bestSkill) {
          const target = bestSkill.id.startsWith('opp-') ? 'player' : 'ai';
          
          const prevValues = calculateCurrentValues(currentLogState);
          const beforeVal = target === 'player' ? prevValues.pCard : prevValues.aCard;
          
          let afterVal;
          if (bestSkill.id === 'random') afterVal = bestRandomVal;
          else afterVal = applySkillValue(beforeVal, bestSkill.id, undefined);

          const newLog = { 
            id: Date.now() + Math.random(), 
            user: 'AI', 
            skill: bestSkill, 
            skillId: bestSkill.id, 
            target, 
            nullified: false,
            storedValue: bestRandomVal,
            beforeVal, 
            afterVal
          };
          
          const nextLogs = [...currentLogState, newLog];
          setSkillLog(nextLogs);
          
          if (bestSkill.id !== 'retrieve') {
            const calculated = calculateCurrentValues(nextLogs);
            setPlayerCard(calculated.pCard);
            setAiCard(calculated.aCard);
          }
          
          const nextSkills = currentAiSkills.filter(s => s.uniqueId !== bestSkill.uniqueId);
          updateAiSkills(nextSkills);

          triggerEffect(bestSkill.id, target);

          setTimeout(() => aiRespond(nextLogs, nextSkills), 1000);
        } else {
          setAiThinking(false);
          setMessage('ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ê±°ë‚˜ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”');
        }
      };

      const triggerAiReaction = (currentLogs, currentSkills) => {
        setAiThinking(true);
        setMessage('AIê°€ ìƒê° ì¤‘...');
        setTimeout(() => aiRespond(currentLogs, currentSkills), 1000);
      };

      useEffect(() => {
        if (aiThinking) return;
        
        const aiNullifyIndex = aiSkillsRef.current.findIndex(s => s.id === 'nullify');
        if (turnPhase === 'skill' && aiNullifyIndex !== -1) {
          const playerLogs = skillLog.filter(l => l.user === 'í”Œë ˆì´ì–´' && !l.nullified);
          const lastPlayerLog = playerLogs[playerLogs.length - 1];
          
          if (lastPlayerLog) {
            const { pCard, aCard } = calculateCurrentValues(skillLog);
            const currentWinner = getWinner(pCard, aCard);
            
            if (currentWinner === 'player-win') {
              setAiThinking(true);
              setTimeout(() => {
                 const newLogs = skillLog.map(l => l.id === lastPlayerLog.id ? { ...l, nullified: true } : l);
                 setSkillLog(newLogs);
                 
                 const nullifySkill = aiSkillsRef.current[aiNullifyIndex];
                 const nextSkills = aiSkillsRef.current.filter(s => s.uniqueId !== nullifySkill.uniqueId);
                 updateAiSkills(nextSkills);

                 const recalculated = calculateCurrentValues(newLogs);
                 setPlayerCard(recalculated.pCard); 
                 setAiCard(recalculated.aCard);
                 
                 triggerEffect('nullify', lastPlayerLog.target);
                 
                 setTimeout(() => aiRespond(newLogs, nextSkills), 1000);
              }, 1000);
            }
          }
        }
      }, [skillLog, turnPhase, aiThinking]);

      const playCard = (card) => {
        if (gameState !== 'playing' || turnPhase !== 'select') return;
        learnPattern(card, playerHand.length);
        originalPlayerCardRef.current = card;
        setPlayerCard(card);
        setPlayerHand(prev => prev.filter(c => c !== card));
        
        const aiSelected = aiSelectCard(aiHand);
        originalAiCardRef.current = aiSelected;
        setAiCard(aiSelected);
        setAiHand(prev => prev.filter(c => c !== aiSelected));
        
        setTurnPhase('skill'); 
        setMessage('AIê°€ ìƒê° ì¤‘...'); 
        setSkillLog([]);
        setAiThinking(true); 
        setAiRetrievePending(false);
        
        setTimeout(() => aiRespond([], aiSkillsRef.current), 800);
      };

      const useSkill = (skill, skillIndex) => {
        if (turnPhase !== 'skill' || aiThinking) return;
        if (originalPlayerCardRef.current === null) return;

        setAiThinking(true); 

        if (skill.id === 'nullify') { 
            setNullifyMode(true); 
            setMessage('ë¬´ë ¥í™”í•  ìŠ¤í‚¬ ì„ íƒ'); 
            setAiThinking(false); 
            return; 
        }
        if (skill.id === 'retrieve') {
          const originalP = originalPlayerCardRef.current;
          const originalA = originalAiCardRef.current;
          if (originalP !== null) {
             setPlayerHand(prev => [...prev, originalP].sort((a,b) => a-b));
             setAiHand(prev => [...prev, originalA].sort((a,b) => a-b));
             setPlayerCard(null); setAiCard(null);
             originalPlayerCardRef.current = null; originalAiCardRef.current = null;
             
             setAiHand(prev => [...prev, originalA].sort((a,b) => a-b));
             setTurnPhase('select'); setMessage('ì¹´ë“œë¥¼ íšŒìˆ˜í–ˆìŠµë‹ˆë‹¤.'); setPlayerSkills(prev => prev.filter((_, i) => i !== skillIndex)); setSkillLog([]); 
             
             triggerEffect('retrieve', 'player');
             setAiThinking(false); 
             return;
          }
        }
        
        let simulatedRandomVal = undefined;
        if (skill.id === 'random') {
           simulatedRandomVal = Math.floor(Math.random() * 11);
        }

        const target = skill.id.startsWith('opp-') ? 'ai' : 'player';
        
        const { pCard, aCard } = calculateCurrentValues(skillLog);
        const beforeVal = target === 'player' ? pCard : aCard;
        let afterVal;
        
        if (skill.id === 'retrieve') { afterVal = null; } 
        else if (skill.id === 'random') { afterVal = simulatedRandomVal; } 
        else { afterVal = applySkillValue(beforeVal, skill.id, undefined); }

        const newLog = { 
          id: Date.now(), 
          user: 'í”Œë ˆì´ì–´', 
          skill, 
          skillId: skill.id, 
          target, 
          nullified: false,
          storedValue: simulatedRandomVal,
          beforeVal, 
          afterVal   
        };
        
        const nextLogs = [...skillLog, newLog];
        setSkillLog(nextLogs);
        
        if (skill.id !== 'retrieve') {
          const calculated = calculateCurrentValues(nextLogs);
          setPlayerCard(calculated.pCard); setAiCard(calculated.aCard);
        }
        
        setPlayerSkills(prev => prev.filter((_, i) => i !== skillIndex));
        triggerEffect(skill.id, target);
        triggerAiReaction(nextLogs, aiSkillsRef.current);
      };

      const nullifySkill = (logId) => {
        if (aiThinking) return;
        setAiThinking(true);

        const nullifyIndex = playerSkills.findIndex(s => s.id === 'nullify');
        if (nullifyIndex === -1) { setAiThinking(false); return; }
        
        const targetLog = skillLog.find(l => l.id === logId);
        const newLogs = skillLog.map(l => l.id === logId ? { ...l, nullified: true } : l);
        setSkillLog(newLogs);
        const { pCard, aCard } = calculateCurrentValues(newLogs);
        setPlayerCard(pCard); setAiCard(aCard);
        setPlayerSkills(prev => prev.filter((_, i) => i !== nullifyIndex));
        setNullifyMode(false); setMessage('ìŠ¤í‚¬ì´ ë¬´ë ¥í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');

        if (targetLog) triggerEffect('nullify', targetLog.target);
        
        // [FIX] ë¬´ë ¥í™” ì„±ê³µ ì‹œ íšŒìˆ˜ ëŒ€ê¸° ìƒíƒœ í•´ì œ
        if (targetLog && targetLog.skillId === 'retrieve' && targetLog.user === 'AI') {
           setAiRetrievePending(false);
           setMessage('AIì˜ íšŒìˆ˜ê°€ ë¬´ë ¥í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        triggerAiReaction(newLogs, aiSkillsRef.current);
      };

      const confirmTurn = () => {
        if (aiThinking) return;
        
        // [CRITICAL] íšŒìˆ˜ ìŠ¤í‚¬ ì²´í¬ (ê°€ì¥ ë§ˆì§€ë§‰ ìœ íš¨í•œ íšŒìˆ˜ ìŠ¤í‚¬ ìš°ì„ )
        const activeRetrieve = [...skillLog].reverse().find(l => l.skillId === 'retrieve' && !l.nullified);
        
        if (activeRetrieve) {
          const originalP = originalPlayerCardRef.current;
          const originalA = originalAiCardRef.current;
          
          setPlayerHand(prev => [...prev, originalP].sort((a,b) => a-b));
          setAiHand(prev => [...prev, originalA].sort((a,b) => a-b));
          setPlayerCard(null); setAiCard(null); 
          originalPlayerCardRef.current = null; originalAiCardRef.current = null;
          
          setTurnPhase('select'); 
          setMessage(`${activeRetrieve.user}ì˜ íšŒìˆ˜ë¡œ í„´ì´ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤.`); 
          setSkillLog([]);
          setActiveEffects([]);
          setAiRetrievePending(false);
          return;
        }

        setTurnPhase('result');
        const winner = getWinner(playerCard, aiCard);
        const isTenVsZero = (playerCard === 10 && aiCard === 0) || (playerCard === 0 && aiCard === 10);

        if (winner === 'player-win') {
          setPlayerScore(prev => prev + 1);
          setResultType('win');
          setMessage(`ìŠ¹ë¦¬! (${playerCard} vs ${aiCard})`);
        } else if (winner === 'ai-win') {
          setAiScore(prev => prev + 1);
          setResultType('lose');
          setMessage(`íŒ¨ë°°! (${playerCard} vs ${aiCard})`);
        } else {
          setResultType('draw');
          setMessage(`ë¬´ìŠ¹ë¶€! (${playerCard} vs ${aiCard})`);
        }

        if (isTenVsZero) {
          if (winner === 'player-win') setPlayerSkills(prev => [...prev, getRandomSkill(), getRandomSkill()]);
          else if (winner === 'ai-win') updateAiSkills([...aiSkillsRef.current, getRandomSkill(), getRandomSkill()]);
        } else {
          const diff = Math.abs(playerCard - aiCard);
          if (diff === 1 || winner === 'draw') {
            if (winner === 'player-win' || winner === 'draw') setPlayerSkills(prev => [...prev, getRandomSkill()]);
            if (winner === 'ai-win' || winner === 'draw') updateAiSkills([...aiSkillsRef.current, getRandomSkill()]);
          }
        }

        if (playerHand.length === 0) {
          setTimeout(() => {
            if (round >= MAX_ROUNDS) setGameState('game-over');
            else setGameState('round-end');
          }, 2000);
        } else {
          setTimeout(() => {
            setPlayerCard(null); setAiCard(null); 
            originalPlayerCardRef.current = null; originalAiCardRef.current = null;
            setTurnPhase('select'); setMessage('ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”'); setSkillLog([]); setResultType(null);
            setActiveEffects([]);
          }, 2000);
        }
      };

      const nextRound = () => {
        setRound(prev => prev + 1);
        grantRoundSkills(round + 1);
        initGame();
      };

      const Card = ({ number, isHidden, isSelected, onClick, disabled }) => (
        <button onClick={onClick} disabled={disabled}
          className={`relative w-14 h-20 sm:w-16 sm:h-24 rounded-lg border-2 shadow-lg transition-all duration-100 transform flex flex-col items-center justify-center
            active:scale-95 touch-manipulation
            ${isHidden ? 'bg-red-900 border-red-950 bg-opacity-90' : 'bg-white border-gray-300 hover:border-blue-500 sm:hover:-translate-y-1 text-gray-800'}
            ${isSelected ? 'ring-4 ring-yellow-400 scale-105 z-10' : ''}
            ${disabled && !isHidden ? 'opacity-50 cursor-not-allowed' : ''}`}>
          {!isHidden && (<><span className="absolute top-1 left-1 text-xs font-bold">{number}</span><span className="text-2xl sm:text-4xl font-bold">{number}</span><span className="absolute bottom-1 right-1 text-xs font-bold transform rotate-180">{number}</span></>)}
          {isHidden && (<div className="w-full h-full flex items-center justify-center opacity-20"><div className="w-8 h-8 rounded-full border-2 border-white"></div></div>)}
        </button>
      );

      const EffectLayer = ({ target }) => {
        const myEffects = activeEffects.filter(e => e.target === target);
        return (
          <div className="absolute inset-0 pointer-events-none flex items-center justify-center z-50">
            {myEffects.map(e => {
              let Content = null;
              let animationClass = '';
              if (e.skillId.includes('plus')) {
                Content = <span className="text-4xl font-black text-green-400 drop-shadow-lg stroke-black">+1</span>;
                animationClass = 'effect-float';
              } else if (e.skillId.includes('minus')) {
                Content = <span className="text-4xl font-black text-red-500 drop-shadow-lg stroke-black">-1</span>;
                animationClass = 'effect-float';
              } else if (e.skillId === 'double') {
                Content = <div className="flex flex-col items-center"><span className="text-6xl">âš¡</span><span className="text-4xl font-black text-yellow-300">x2</span></div>;
                animationClass = 'effect-lightning';
              } else if (e.skillId === 'random') {
                Content = <div className="text-5xl font-bold text-purple-400">ğŸ²</div>;
                animationClass = 'effect-roll';
              } else if (e.skillId === 'retrieve') {
                Content = <div className="text-6xl text-blue-500">ğŸŒ€</div>;
                animationClass = 'effect-spin';
              } else if (e.skillId === 'nullify') {
                Content = <div className="text-8xl text-red-600 opacity-80">ğŸš«</div>;
                animationClass = 'effect-stamp';
              }
              return <div key={e.id} className={`absolute ${animationClass}`}>{Content}</div>;
            })}
          </div>
        );
      };

      const LeaderboardModal = () => (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 backdrop-blur-sm animate-pop">
          <div className="bg-gray-800 w-full max-w-md rounded-xl border border-yellow-600/50 shadow-2xl p-6">
            <div className="flex justify-between items-center mb-6">
              <h3 className="text-2xl font-bold text-yellow-400 flex items-center gap-2"><Icons.Trophy /> Top Rankers</h3>
              <button onClick={() => setShowLeaderboard(false)} className="text-gray-400 hover:text-white text-xl font-bold p-2">&times;</button>
            </div>
            <div className="space-y-2 mb-6 overflow-y-auto max-h-64 custom-scroll">
              {leaderboard.length === 0 ? (
                <div className="text-gray-500 text-center py-4">ê¸°ë¡ì´ ì—†ê±°ë‚˜ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
              ) : (
                leaderboard.map((entry, i) => (
                  <div key={entry.id || i} className={`flex justify-between p-3 rounded ${i===0 ? 'bg-yellow-900/40 border border-yellow-600/30' : 'bg-gray-700'}`}>
                    <div className="flex gap-3">
                      <span className={`font-bold w-6 ${i===0 ? 'text-yellow-400' : i===1 ? 'text-gray-300' : i===2 ? 'text-amber-600' : 'text-gray-500'}`}>#{i+1}</span>
                      <span className="text-white truncate max-w-[120px]">{entry.name}</span>
                    </div>
                    <span className="font-mono text-yellow-200 font-bold">{entry.score} pts</span>
                  </div>
                ))
              )}
            </div>
            <button onClick={() => setShowLeaderboard(false)} className="w-full py-3 bg-gray-600 hover:bg-gray-500 text-white rounded-lg transition active:scale-95">ë‹«ê¸°</button>
          </div>
        </div>
      );
      
      const RuleModal = () => (
        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 backdrop-blur-sm animate-pop">
          <div className="bg-gray-900 w-full max-w-2xl rounded-xl border border-green-600/50 shadow-2xl p-6 flex flex-col max-h-[90vh]">
            <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
              <h3 className="text-2xl font-bold text-green-400 flex items-center gap-2"><Icons.BookOpen /> ê²Œì„ ì„¤ëª…ì„œ</h3>
              <button onClick={() => setShowRules(false)} className="text-gray-400 hover:text-white text-xl font-bold p-2">&times;</button>
            </div>
            <div className="flex-1 overflow-y-auto custom-scroll space-y-6 pr-2 text-gray-200 text-sm leading-relaxed">
              <section>
                <h4 className="text-lg font-bold text-yellow-400 mb-2">1. ê¸°ë³¸ ê·œì¹™</h4>
                <ul className="list-disc list-inside space-y-1 ml-2">
                  <li><strong>0ë¶€í„° 10ê¹Œì§€</strong>ì˜ ìˆ«ì ì¹´ë“œë¥¼ í•œ ì¥ì”© ëƒ…ë‹ˆë‹¤.</li>
                  <li>ìƒëŒ€ë³´ë‹¤ <strong>ì‘ì€ ìˆ«ì</strong>ë¥¼ ë‚´ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</li>
                  <li>ë‹¨, <strong>10ì€ 0ì„ ì´ê¹ë‹ˆë‹¤.</strong></li>
                  <li>ë¹„ê¸°ê±°ë‚˜ 1 ì°¨ì´ë¡œ ìŠ¹ë¶€ ì‹œ ìŠ¤í‚¬ 1ì¥ ì§€ê¸‰</li>
                  <li><strong>10 vs 0</strong> ìŠ¹ë¦¬ ì‹œ ìŠ¤í‚¬ <strong>2ì¥</strong> ì§€ê¸‰!</li>
                </ul>
              </section>
              <section>
                <h4 className="text-lg font-bold text-yellow-400 mb-2">2. ìŠ¤í‚¬ ì„¤ëª…</h4>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {skillTypes.map((skill) => (
                    <div key={skill.id} className="bg-gray-800 p-3 rounded border border-gray-700 flex flex-col gap-1">
                      <div className="flex items-center gap-2 font-bold">
                        <div className={`w-5 h-5 rounded ${skill.color} flex items-center justify-center shadow-sm text-white`}><SkillIcon iconName={skill.icon} /></div>
                        <span className="text-white">{skill.name}</span>
                      </div>
                      <p className="text-xs text-gray-400">{skill.desc}</p>
                      {skill.id === 'double' && <p className="text-[10px] text-yellow-200 mt-1">ì˜ˆ: 6â†’12(2), 10â†’20(0), 5â†’10</p>}
                    </div>
                  ))}
                </div>
              </section>
            </div>
            <button onClick={() => setShowRules(false)} className="mt-4 w-full py-3 bg-green-700 hover:bg-green-600 text-white rounded-lg transition font-bold">ì•Œê² ìŠµë‹ˆë‹¤!</button>
          </div>
        </div>
      );
      
      const SkillIcon = ({ iconName }) => {
        const Icon = Icons[iconName];
        return Icon ? <Icon /> : null;
      };

      return (
        <div className="w-full min-h-screen flex items-center justify-center p-0 sm:p-4 overflow-hidden relative">
          <div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'radial-gradient(circle, #ffffff 1px, transparent 1px)', backgroundSize: '20px 20px'}}></div>

          {showLeaderboard && <LeaderboardModal />}
          {showRules && <RuleModal />}

          <div className="w-full max-w-5xl bg-green-900/90 backdrop-blur-sm sm:rounded-3xl shadow-2xl border-x-0 sm:border border-green-700 overflow-hidden flex flex-col lg:flex-row h-screen sm:h-auto sm:min-h-[650px]">
            
            <div className="flex-1 flex flex-col relative overflow-y-auto">
              <div className="bg-black/30 p-2 sm:p-3 flex justify-between items-center border-b border-white/10 shrink-0">
                <div className="flex flex-col">
                  <div className="flex items-center gap-2">
                    <span className="text-red-300 font-bold text-sm">AI OPPONENT</span>
                    {aiThinking && <span className="text-yellow-400 text-xs animate-thinking">ğŸ¤” ìƒê° ì¤‘...</span>}
                  </div>
                  <span className="text-xs text-gray-400">Lv. Aggressive</span>
                </div>
                <div className="flex items-center gap-3">
                  <button 
                    onClick={() => setShowAiSkills(!showAiSkills)}
                    className={`p-1.5 rounded-full transition-colors ${showAiSkills ? 'bg-yellow-500 text-black' : 'bg-gray-700 text-gray-400 hover:text-white'}`}
                    title="ìƒëŒ€ ìŠ¤í‚¬ ìƒì„¸ë³´ê¸°"
                  >
                    {showAiSkills ? <Icons.Eye /> : <Icons.EyeOff />}
                  </button>
                  <div className="text-2xl font-bold text-white font-mono">{aiScore}</div>
                </div>
              </div>

              <div className="flex-1 flex flex-col items-center justify-center p-2 gap-4 min-h-[200px]">
                <div className={`flex flex-wrap justify-center gap-1.5 transition-all duration-300 ${showAiSkills ? 'min-h-[60px]' : 'h-8'}`}>
                  {aiSkills.map((skill, i) => (
                    showAiSkills ? (
                      <div key={i} className={`px-2 py-1 ${skill.color} rounded flex items-center gap-1 text-[10px] text-white shadow-md animate-pop`} title={skill.desc}>
                        <SkillIcon iconName={skill.icon} />
                        <span>{skill.name}</span>
                      </div>
                    ) : (
                      <div key={i} className={`w-5 h-5 rounded ${skill.color} flex items-center justify-center shadow-sm`} title={skill.name}>
                        <span className="text-[8px] text-white">âš¡</span>
                      </div>
                    )
                  ))}
                  {aiSkills.length === 0 && <span className="text-xs text-gray-500 self-center">No Skills</span>}
                </div>

                <div className="flex items-center gap-8 relative">
                   <div className="relative">
                     <div className="absolute -top-6 w-full text-center text-xs text-gray-400">HAND: {aiHand.length}</div>
                     {aiCard !== null ? <Card number={aiCard} isHidden={turnPhase === 'select' && !resultType} /> : <div className="w-14 h-20 sm:w-16 sm:h-24 border-2 border-dashed border-white/20 rounded-lg flex items-center justify-center text-white/20">Empty</div>}
                     <EffectLayer target="ai" />
                   </div>
                </div>
              </div>

              <div className={`py-2 text-center transition-colors duration-300 shrink-0 ${resultType === 'win' ? 'bg-blue-600/50' : resultType === 'lose' ? 'bg-red-600/50' : 'bg-black/20'}`}>
                <h2 className="text-yellow-400 font-bold text-xs uppercase tracking-widest mb-1">Round {round} / {MAX_ROUNDS}</h2>
                <div className="text-lg sm:text-xl text-white font-bold drop-shadow-md animate-pop px-2">{message}</div>
                {turnPhase === 'skill' && (
                  <button 
                    onClick={confirmTurn} 
                    disabled={aiThinking}
                    className={`mt-2 px-6 py-2 font-bold rounded-full text-sm shadow-lg transition-all
                      ${aiThinking 
                        ? 'bg-gray-500 text-gray-300 cursor-not-allowed' 
                        : 'bg-yellow-500 active:bg-yellow-600 text-black active:scale-95'}`}
                  >
                    {aiThinking ? 'AI ìƒê° ì¤‘...' : 'ê²°ê³¼ í™•ì¸ (Turn End)'}
                  </button>
                )}
              </div>

              <div className="flex-1 flex flex-col items-center justify-start p-2 sm:p-4 gap-3 bg-black/10">
                 <div className="flex justify-center relative">
                    {playerCard !== null ? <Card number={playerCard} isSelected={true} /> : <div className="w-14 h-20 sm:w-16 sm:h-24 border-2 border-dashed border-blue-400/30 rounded-lg flex items-center justify-center text-blue-200/30 text-sm">Select</div>}
                    <EffectLayer target="player" />
                 </div>
                 
                 <div className="flex flex-wrap justify-center gap-2 min-h-[32px]">
                    {playerSkills.map((skill, i) => (
                      <button key={i} onClick={() => useSkill(skill, i)} disabled={turnPhase !== 'skill' || aiThinking} 
                        className={`px-3 py-2 sm:px-2 sm:py-1 ${skill.color} text-white rounded text-xs flex items-center gap-1 active:scale-95 touch-manipulation shadow hover:brightness-110 disabled:opacity-50 disabled:cursor-not-allowed`}>
                        <SkillIcon iconName={skill.icon} />
                        <span className="inline">{skill.name}</span>
                      </button>
                    ))}
                 </div>
                 
                 <div className="w-full flex justify-center gap-2 flex-wrap pb-2">
                   {playerHand.map((card, i) => <Card key={`${card}-${i}`} number={card} onClick={() => playCard(card)} disabled={turnPhase !== 'select'} />)}
                 </div>
              </div>

              <div className="bg-black/30 p-2 sm:p-3 flex justify-between items-center border-t border-white/10 shrink-0">
                <div className="flex flex-col"><span className="text-blue-300 font-bold text-sm">PLAYER</span><span className="text-xs text-gray-400">10 beats 0 â†’ +2 Skills</span></div>
                <div className="text-2xl font-bold text-white font-mono">{playerScore}</div>
              </div>
            </div>

            <div className="w-full lg:w-64 bg-black/40 border-t lg:border-t-0 lg:border-l border-white/10 p-4 flex flex-col max-h-48 lg:max-h-none shrink-0">
              <h3 className="text-yellow-500 font-bold text-xs uppercase tracking-wider mb-2 sticky top-0">Battle Log {nullifyMode && <span className="text-red-500 animate-blink">(Select Target)</span>}</h3>
              <div className="flex-1 overflow-y-auto custom-scroll space-y-2 pr-1">
                {skillLog.length === 0 && <div className="text-gray-500 text-xs text-center py-2">ìŠ¤í‚¬ ê¸°ë¡ ì—†ìŒ</div>}
                {skillLog.map((log) => (
                  <div key={log.id} onClick={() => nullifyMode && !log.nullified && !aiThinking && nullifySkill(log.id)} className={`p-2 rounded text-xs text-white ${log.nullified ? 'bg-gray-800 opacity-50' : log.skill.color} ${nullifyMode && !log.nullified && !aiThinking ? 'cursor-pointer animate-shake ring-2 ring-white' : ''}`}>
                    <div className="flex justify-between"><strong>{log.user}</strong>{log.nullified && <span className="text-red-300 line-through">ë¬´íš¨ë¨</span>}</div>
                    <div className="flex items-center gap-1">
                      <span>{log.skill.name}</span>
                      <span className="opacity-75 text-[10px]">â†’ {log.target === 'player' ? 'ë‚˜' : 'ìƒëŒ€'}</span>
                    </div>
                    {!log.nullified && log.beforeVal !== undefined && (
                      <div className="text-[10px] font-mono mt-1 bg-black/20 px-1 rounded inline-block">
                        {log.beforeVal} â†’ <span className="font-bold text-yellow-200">{log.afterVal}</span>
                      </div>
                    )}
                  </div>
                ))}
              </div>
              {nullifyMode && <button onClick={() => { setNullifyMode(false); setAiThinking(false); }} className="mt-2 w-full py-3 bg-gray-600 text-white text-xs rounded-lg active:scale-95">ì·¨ì†Œ</button>}
            </div>

            {gameState === 'start' && (
              <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6 text-center">
                <h1 className="text-5xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600 mb-6">ZERO POINT</h1>
                <div className="bg-green-800/50 border border-green-500/30 p-6 rounded-xl max-w-md w-full mb-8 text-white text-sm space-y-2 backdrop-blur">
                  <p>â˜… <strong>5ë¼ìš´ë“œ</strong> ì ìˆ˜ ê²½ìŸ</p>
                  <p>â˜… <strong>ì‘ì€ ìˆ«ì</strong> ìŠ¹ë¦¬ (ë‹¨, 10ì€ 0ì„ ì´ê¹€)</p>
                  <p>â˜… 1ì ì°¨/ë¬´ìŠ¹ë¶€ ì‹œ ìŠ¤í‚¬ 1ì¥, <strong>10 vs 0</strong> ìŠ¹ë¦¬ ì‹œ 2ì¥!</p>
                </div>
                <div className="flex flex-col sm:flex-row gap-4 w-full max-w-sm justify-center">
                  <button onClick={resetCampaign} className="px-8 py-4 bg-yellow-500 active:bg-yellow-400 text-black font-bold rounded-full shadow-lg active:scale-95 transition-transform">START GAME</button>
                  <button onClick={() => setShowLeaderboard(true)} className="px-6 py-4 bg-gray-700 active:bg-gray-600 text-white font-bold rounded-full shadow-lg active:scale-95">RANKING</button>
                  <button onClick={() => setShowRules(true)} className="px-6 py-4 bg-green-700 active:bg-green-600 text-white font-bold rounded-full shadow-lg active:scale-95 flex items-center justify-center gap-2">
                    <Icons.BookOpen /> ê²Œì„ ì„¤ëª…
                  </button>
                </div>
              </div>
            )}

            {gameState === 'round-end' && (
              <div className="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center animate-pop p-4 text-center">
                <h2 className="text-3xl font-bold text-white mb-4">ROUND {round} COMPLETE</h2>
                <div className="text-2xl text-white mb-8 font-mono border p-4 rounded-lg">Player {playerScore} : {aiScore} AI</div>
                <button onClick={nextRound} className="w-full max-w-xs px-8 py-4 bg-blue-600 active:bg-blue-500 text-white font-bold rounded-lg active:scale-95 transition">Next Round</button>
              </div>
            )}

            {gameState === 'game-over' && (
              <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6 animate-pop text-center">
                <h2 className="text-4xl font-bold text-yellow-400 mb-2">GAME FINISHED</h2>
                <p className="text-gray-400 mb-6">ì´ 5ë¼ìš´ë“œ ì¢…ë£Œ</p>
                
                <div className="bg-white/10 p-6 rounded-xl mb-8 w-full max-w-xs border border-white/20">
                  <div className="text-sm text-gray-400 mb-1">YOUR FINAL SCORE</div>
                  <div className="text-6xl font-black text-white">{playerScore}</div>
                </div>

                <div className="w-full max-w-xs space-y-3">
                  <input 
                    type="text" 
                    maxLength="8"
                    placeholder="ì´ë¦„ ì…ë ¥ (3-8ì)" 
                    className="w-full px-4 py-3 rounded-lg bg-gray-800 border border-gray-600 text-white text-center focus:border-yellow-500 outline-none text-lg"
                    value={playerName}
                    onChange={(e) => setPlayerName(e.target.value)}
                  />
                  <button 
                    onClick={submitScore} 
                    disabled={!playerName.trim() || isSubmitting}
                    className="w-full py-4 bg-green-600 hover:bg-green-500 disabled:bg-gray-700 disabled:cursor-not-allowed text-white font-bold rounded-lg transition flex justify-center items-center gap-2 active:scale-95"
                  >
                    {isSubmitting ? 'ì €ì¥ ì¤‘...' : 'ì ìˆ˜ ì €ì¥ & ë­í‚¹ ë³´ê¸°'}
                  </button>
                  <button onClick={() => setGameState('start')} className="w-full py-3 text-gray-400 active:text-white text-sm">ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
                </div>
              </div>
            )}

          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ZeroPointGame />);
  </script>
</body>
</html>
