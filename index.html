<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="icon" href="data:,">
  <title>Zero Point: Ranking Battle</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <style>
    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
    body { font-family: system-ui, -apple-system, sans-serif; background-color: #1a2e1a; touch-action: manipulation; margin: 0; }
    
    @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-2px); } 75% { transform: translateX(2px); } }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes thinking { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
    
    @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }
    @keyframes lightning { 0% { opacity: 0; transform: scale(1); } 10% { opacity: 1; transform: scale(1.2); filter: brightness(2); } 30% { opacity: 1; transform: scale(1.1); } 100% { opacity: 0; transform: scale(1); } }
    @keyframes spin-in { 0% { transform: rotate(0deg) scale(0); opacity: 0; } 50% { transform: rotate(180deg) scale(1.5); opacity: 1; } 100% { transform: rotate(360deg) scale(0); opacity: 0; } }
    @keyframes shake-hard { 0%, 100% { transform: translate(0, 0) rotate(0deg); } 25% { transform: translate(-5px, 5px) rotate(-5deg); } 75% { transform: translate(-5px, -5px) rotate(-5deg); } }
    @keyframes stamp { 0% { transform: scale(2); opacity: 0; } 50% { transform: scale(1); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
    @keyframes roll { 0% { transform: rotate(0deg); } 100% { transform: rotate(720deg); } }

    .animate-pop { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .animate-shake { animation: shake 0.2s ease-in-out infinite; }
    .animate-blink { animation: blink 1s infinite; }
    .animate-thinking { animation: thinking 1s infinite; }
    
    .effect-float { animation: floatUp 1s forwards; }
    .effect-lightning { animation: lightning 0.6s ease-out forwards; }
    .effect-spin { animation: spin-in 0.8s ease-in-out forwards; }
    .effect-stamp { animation: stamp 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    .effect-roll { animation: roll 0.8s ease-in-out forwards; }
    .effect-shake-hard { animation: shake-hard 0.5s ease-in-out infinite; }

    .custom-scroll::-webkit-scrollbar { width: 4px; }
    .custom-scroll::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
    .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const APP_VERSION = "v1.4.1 (Hidden)";
    const MAX_ROUNDS = 5;
    
    const firebaseConfig = {
      apiKey: "AIzaSyBYV5nAO4sswR9prt88trv2u1L_f_kCyaU",
      authDomain: "zero-9c4b4.firebaseapp.com",
      projectId: "zero-9c4b4",
      storageBucket: "zero-9c4b4.firebasestorage.app",
      messagingSenderId: "1009247488012",
      appId: "1:1009247488012:web:c11f59dce6b5aef9d38629",
      measurementId: "G-C1329R3S78"
    };

    let db;
    try {
      if (firebaseConfig.projectId) {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
      }
    } catch (e) { console.error("Firebase Init Error", e); }

    const SKILL_TYPES = [
      { id: 'retrieve', name: 'ÌöåÏàò', icon: 'RotateCcw', desc: 'Î∞©Í∏à ÎÇ∏ Ïπ¥ÎìúÎ•º ÏÜêÌå®Î°ú ÌöåÏàòÌï©ÎãàÎã§.', color: 'bg-blue-600' },
      { id: 'opp-plus', name: 'ÏÉÅÎåÄ+1', icon: 'Plus', desc: 'ÏÉÅÎåÄ Ïπ¥Îìú +1 (10‚Üí0)', color: 'bg-red-600' },
      { id: 'opp-minus', name: 'ÏÉÅÎåÄ-1', icon: 'Minus', desc: 'ÏÉÅÎåÄ Ïπ¥Îìú -1 (0‚Üí10)', color: 'bg-red-500' },
      { id: 'self-plus', name: 'Î≥∏Ïù∏+1', icon: 'Plus', desc: 'Î≥∏Ïù∏ Ïπ¥Îìú +1 (10‚Üí0)', color: 'bg-green-600' },
      { id: 'self-minus', name: 'Î≥∏Ïù∏-1', icon: 'Minus', desc: 'Î≥∏Ïù∏ Ïπ¥Îìú -1 (0‚Üí10)', color: 'bg-green-500' },
      { id: 'double', name: '2Î∞∞', icon: 'Zap', desc: 'Î≥∏Ïù∏ Ïπ¥Îìú x2 (10 Ï¥àÍ≥ºÏãú ÏùºÏùò ÏûêÎ¶¨)', color: 'bg-yellow-600' },
      { id: 'random', name: 'ÎûúÎç§', icon: 'Shuffle', desc: 'Î≥∏Ïù∏ Ïπ¥Îìú 0~10 ÎûúÎç§ Î≥ÄÍ≤Ω', color: 'bg-purple-600' },
      { id: 'nullify', name: 'Î¨¥Î†•Ìôî', icon: 'Ban', desc: 'Ïä§ÌÇ¨ Ìö®Í≥º Ï∑®ÏÜå', color: 'bg-gray-700' }
    ];

    const createSkill = (typeId) => {
      const type = SKILL_TYPES.find(s => s.id === typeId) || SKILL_TYPES[0];
      return { ...type, uniqueId: Date.now() + Math.random() };
    };

    const getRandomSkill = () => {
      const type = SKILL_TYPES[Math.floor(Math.random() * SKILL_TYPES.length)];
      return { ...type, uniqueId: Date.now() + Math.random() };
    };

    const Icons = {
      Shuffle: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.7-1.1 2-1.7 3.3-1.7H22"/><path d="m18 2 4 4-4 4"/><path d="M2 6h1.9c1.5 0 2.9.9 3.6 2.2"/><path d="M22 18h-5.9c-1.3 0-2.6-.7-3.3-1.8l-.5-.8"/><path d="m18 14 4 4-4 4"/></svg>,
      RotateCcw: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
      Plus: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12h14"/><path d="M12 5v14"/></svg>,
      Minus: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12h14"/></svg>,
      Zap: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
      Ban: () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></svg>,
      Trophy: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>,
      Eye: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>,
      EyeOff: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7c.44 0 .87-.03 1.28-.08"/><line x1="2" y1="2" x2="22" y2="22"/></svg>,
      BookOpen: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
      Settings: () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
    };

    const Card = ({ number, isHidden, isSelected, onClick, disabled }) => (
      <button onClick={onClick} disabled={disabled}
        className={`relative w-14 h-20 sm:w-16 sm:h-24 rounded-lg border-2 shadow-lg transition-all duration-100 transform flex flex-col items-center justify-center
          active:scale-95 touch-manipulation select-none
          ${isHidden ? 'bg-red-900 border-red-950 bg-opacity-90' : 'bg-white border-gray-300 hover:border-blue-500 sm:hover:-translate-y-1 text-gray-800'}
          ${isSelected ? 'ring-4 ring-yellow-400 scale-105 z-10' : ''}
          ${disabled && !isHidden ? 'opacity-50 cursor-not-allowed' : ''}`}>
        {!isHidden && (<><span className="absolute top-1 left-1 text-xs font-bold">{number}</span><span className="text-2xl sm:text-4xl font-bold">{number}</span><span className="absolute bottom-1 right-1 text-xs font-bold transform rotate-180">{number}</span></>)}
        {isHidden && (<div className="w-full h-full flex items-center justify-center opacity-20"><div className="w-8 h-8 rounded-full border-2 border-white"></div></div>)}
      </button>
    );

    const SkillBadge = ({ skill, onClick, disabled }) => {
      const IconComp = Icons[skill.icon];
      return (
        <button onClick={onClick} disabled={disabled} className={`px-2 py-1 ${skill.color} text-white rounded text-xs flex items-center gap-1 active:scale-95 shadow hover:brightness-110 disabled:opacity-50 disabled:cursor-not-allowed`}>
          {IconComp && <IconComp />}
          <span className="inline">{skill.name}</span>
        </button>
      );
    };

    const EffectLayer = ({ activeEffects, target }) => {
      const myEffects = activeEffects.filter(e => e.target === target);
      return (
        <div className="absolute inset-0 pointer-events-none flex items-center justify-center z-50">
          {myEffects.map(e => {
            let Content = null;
            let animationClass = '';
            if (e.skillId.includes('plus')) { Content = <span className="text-4xl font-black text-green-400 drop-shadow-lg stroke-black">+1</span>; animationClass = 'effect-float'; } 
            else if (e.skillId.includes('minus')) { Content = <span className="text-4xl font-black text-red-500 drop-shadow-lg stroke-black">-1</span>; animationClass = 'effect-float'; } 
            else if (e.skillId === 'double') { Content = <div className="flex flex-col items-center"><span className="text-6xl">‚ö°</span><span className="text-4xl font-black text-yellow-300">x2</span></div>; animationClass = 'effect-lightning'; } 
            else if (e.skillId === 'random') { Content = <div className="text-5xl font-bold text-purple-400">üé≤</div>; animationClass = 'effect-roll'; } 
            else if (e.skillId === 'retrieve') { Content = <div className="text-6xl text-blue-500">üåÄ</div>; animationClass = 'effect-spin'; } 
            else if (e.skillId === 'nullify') { Content = <div className="text-8xl text-red-600 opacity-80">üö´</div>; animationClass = 'effect-stamp'; }
            return <div key={e.id} className={`absolute ${animationClass}`}>{Content}</div>;
          })}
        </div>
      );
    };

    const DebugConsole = ({ isOpen, onClose, onAddSkill, onForceCard, aiHand, nextAiCard }) => {
      if (!isOpen) return null;
      return (
        <div className="fixed bottom-4 right-4 bg-gray-900 border border-gray-600 p-4 rounded-lg shadow-2xl z-[9999] w-64 text-xs animate-pop">
          <div className="flex justify-between items-center mb-2 border-b border-gray-700 pb-1">
            <h3 className="font-bold text-green-400">üõ†Ô∏è DEBUG MODE</h3>
            <button onClick={onClose} className="text-gray-400 hover:text-white">‚úï</button>
          </div>
          
          <div className="space-y-3">
            <div>
              <p className="text-gray-400 mb-1">Ïä§ÌÇ¨ ÏßÄÍ∏â</p>
              <div className="grid grid-cols-2 gap-1">
                <select id="debug-skill-select" className="bg-gray-800 text-white rounded p-1 col-span-2">
                  {SKILL_TYPES.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                </select>
                <button onClick={() => onAddSkill(document.getElementById('debug-skill-select').value, 'player')} className="bg-blue-700 text-white p-1 rounded hover:bg-blue-600">ÎÇòÏóêÍ≤å</button>
                <button onClick={() => onAddSkill(document.getElementById('debug-skill-select').value, 'ai')} className="bg-red-700 text-white p-1 rounded hover:bg-red-600">AIÏóêÍ≤å</button>
              </div>
            </div>

            <div>
              <p className="text-gray-400 mb-1">AI Îã§Ïùå Ïπ¥Îìú Í∞ïÏ†ú ({aiHand.length}Ïû• ÎÇ®Ïùå)</p>
              <div className="flex flex-wrap gap-1 bg-gray-800 p-1 rounded max-h-24 overflow-y-auto custom-scroll">
                {aiHand.map((c, i) => (
                  <button key={`${c}-${i}`} 
                    onClick={() => onForceCard(c)}
                    className={`w-6 h-6 rounded ${nextAiCard === c ? 'bg-green-500 text-black font-bold' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}>
                    {c}
                  </button>
                ))}
              </div>
              {nextAiCard !== null && <div className="mt-1 text-green-400">ÏòàÏïΩÎê®: {nextAiCard}</div>}
            </div>
          </div>
        </div>
      );
    };

    const { useState, useEffect, useRef } = React;

    const ZeroPointGame = () => {
      const [gameState, setGameState] = useState('start');
      const [playerHand, setPlayerHand] = useState([]);
      const [aiHand, setAiHand] = useState([]);
      const [playerCard, setPlayerCard] = useState(null);
      const [aiCard, setAiCard] = useState(null);
      const [playerScore, setPlayerScore] = useState(0);
      const [aiScore, setAiScore] = useState(0);
      const [round, setRound] = useState(1);
      const [message, setMessage] = useState('');
      const [playerSkills, setPlayerSkills] = useState([]);
      const [aiSkills, setAiSkills] = useState([]);
      const [skillLog, setSkillLog] = useState([]);
      const [nullifyMode, setNullifyMode] = useState(false);
      const [turnPhase, setTurnPhase] = useState('select');
      const [resultType, setResultType] = useState(null);
      const [showAiSkills, setShowAiSkills] = useState(false);
      const [aiThinking, setAiThinking] = useState(false);
      const [activeEffects, setActiveEffects] = useState([]);
      const [aiRetrievePending, setAiRetrievePending] = useState(false);
      
      const [showDebug, setShowDebug] = useState(false);
      const [debugModeActive, setDebugModeActive] = useState(false);
      const [inputBuffer, setInputBuffer] = useState("");
      const [forceAiCard, setForceAiCard] = useState(null);
      const DEBUG_PASSWORD = "qlalsqhsgh";

      const originalPlayerCardRef = useRef(null);
      const originalAiCardRef = useRef(null);
      const aiSkillsRef = useRef([]);

      const [leaderboard, setLeaderboard] = useState([]);
      const [showLeaderboard, setShowLeaderboard] = useState(false);
      const [showRules, setShowRules] = useState(false);
      const [playerName, setPlayerName] = useState('');
      const [isSubmitting, setIsSubmitting] = useState(false);
      const [aiPattern, setAiPattern] = useState({ totalMoves: 0, lowPref: 0, midPref: 0, highPref: 0, earlyLow: 0, earlyHigh: 0, lateLow: 0, lateHigh: 0 });

      useEffect(() => {
        if (!debugModeActive) return;
        const handleKeyDown = (e) => {
          const newInput = (inputBuffer + e.key).slice(-DEBUG_PASSWORD.length);
          setInputBuffer(newInput);
          if (newInput === DEBUG_PASSWORD) {
            setShowDebug(true);
            setDebugModeActive(false);
            setInputBuffer("");
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [debugModeActive, inputBuffer]);

      useEffect(() => {
        let timer;
        if (aiThinking) {
          timer = setTimeout(() => {
            if (aiThinking) {
              console.warn("AI thinking timeout force release");
              setAiThinking(false);
              setMessage("AI ÏùëÎãµ ÏãúÍ∞Ñ Ï¥àÍ≥º - ÌÑ¥ ÏßÑÌñâ");
            }
          }, 5000);
        }
        return () => clearTimeout(timer);
      }, [aiThinking]);

      const updateAiSkills = (newSkills) => {
        setAiSkills(newSkills);
        aiSkillsRef.current = newSkills;
      };

      const calculateValues = (logs) => {
        let p = originalPlayerCardRef.current;
        let a = originalAiCardRef.current;
        logs.filter(l => !l.nullified).forEach(log => {
          if(log.skillId === 'retrieve') return;
          const val = log.target === 'player' ? p : a;
          const stored = log.storedValue;
          let res = val;
          if(val === null || isNaN(val)) return;
          
          switch(log.skillId) {
            case 'opp-plus': case 'self-plus': res = val+1>10?0:val+1; break;
            case 'opp-minus': case 'self-minus': res = val-1<0?10:val-1; break;
            case 'double': let d = Math.floor(val)*2; res = d>10?d%10:d; break;
            case 'random': res = stored!==undefined?stored:val; break;
          }
          if(log.target==='player') p=res; else a=res;
        });
        return { pCard: p, aCard: a };
      };

      const getWinner = (p, a) => {
        if (p === a) return 'draw';
        if (p === 10 && a === 0) return 'player-win';
        if (a === 10 && p === 0) return 'ai-win';
        return p < a ? 'player-win' : 'ai-win';
      };

      const initGame = () => {
        const deck = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        setPlayerHand([...deck]);
        setAiHand([...deck]);
        setPlayerCard(null); setAiCard(null);
        originalPlayerCardRef.current = null; originalAiCardRef.current = null;
        setGameState('playing'); setTurnPhase('select');
        setMessage('Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî'); setSkillLog([]);
        setResultType(null); setShowAiSkills(false); setAiThinking(false); setActiveEffects([]);
        setAiRetrievePending(false); setForceAiCard(null);
      };

      const grantRoundSkills = (num) => {
        const pSkills = Array(num).fill(null).map(() => getRandomSkill());
        const aSkills = Array(num).fill(null).map(() => getRandomSkill());
        setPlayerSkills(prev => [...prev, ...pSkills]);
        updateAiSkills([...aiSkillsRef.current, ...aSkills]);
      };

      const aiRespond = (currentLogState, currentAiSkills) => {
        if (currentAiSkills.length === 0) { setAiThinking(false); setMessage('Ïä§ÌÇ¨ÏùÑ ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî'); return; }
        const { pCard, aCard } = calculateValues(currentLogState);
        const currentResult = getWinner(pCard, aCard);
        if (currentResult === 'ai-win') { setAiThinking(false); setMessage('Ïä§ÌÇ¨ÏùÑ ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî'); return; }

        let bestSkill = null;
        let bestRandomVal = undefined;
        const combatSkills = currentAiSkills.filter(s => !['nullify', 'retrieve', 'random'].includes(s.id));

        for (const s of combatSkills) {
          let tp = pCard, ta = aCard;
          const val = s.id.startsWith('opp') ? tp : ta;
          let res = val;
          if(s.id.includes('plus')) res = val+1>10?0:val+1;
          else if(s.id.includes('minus')) res = val-1<0?10:val-1;
          else if(s.id === 'double') { let d = Math.floor(val)*2; res = d>10?d%10:d; }
          
          if(s.id.startsWith('opp')) tp=res; else ta=res;
          const r = getWinner(tp, ta);
          if (r === 'ai-win' || (r === 'draw' && currentResult === 'player-win')) { bestSkill = s; break; }
        }

        if (!bestSkill && currentResult === 'player-win') {
          const randomSkill = currentAiSkills.find(s => s.id === 'random');
          if (randomSkill) { bestSkill = randomSkill; bestRandomVal = Math.floor(Math.random()*11); }
        }

        if (!bestSkill && currentResult === 'player-win') {
          const retrieveSkill = currentAiSkills.find(s => s.id === 'retrieve');
          if (retrieveSkill) {
             const newLog = { id: Date.now(), user: 'AI', skill: retrieveSkill, skillId: 'retrieve', target: 'ai', nullified: false };
             const nextLogs = [...currentLogState, newLog];
             setSkillLog(nextLogs);
             updateAiSkills(currentAiSkills.filter(s => s.uniqueId !== retrieveSkill.uniqueId));
             const id = Date.now();
             setActiveEffects(prev => [...prev, { id, skillId: 'retrieve', target: 'ai' }]); setTimeout(()=>setActiveEffects(p=>p.filter(e=>e.id!==id)), 1000);
             setMessage('AIÍ∞Ä ÌöåÏàòÎ•º ÏÇ¨Ïö©ÌñàÏäµÎãàÎã§! (Î¨¥Î†•Ìôî Í∞ÄÎä•)');
             setAiRetrievePending(true); setAiThinking(false); return;
          }
        }

        if (bestSkill) {
          const target = bestSkill.id.startsWith('opp-') ? 'player' : 'ai';
          const { pCard: prevP, aCard: prevA } = calculateValues(currentLogState);
          const beforeVal = target==='player'?prevP:prevA;
          let afterVal;
          if(bestSkill.id==='random') afterVal=bestRandomVal;
          else {
             // manual recalc for log
             if(bestSkill.id.includes('plus')) afterVal = beforeVal+1>10?0:beforeVal+1;
             else if(bestSkill.id.includes('minus')) afterVal = beforeVal-1<0?10:beforeVal-1;
             else if(bestSkill.id==='double') { let d=Math.floor(beforeVal)*2; afterVal=d>10?d%10:d; }
          }

          const newLog = { id: Date.now(), user: 'AI', skill: bestSkill, skillId: bestSkill.id, target, nullified: false, storedValue: bestRandomVal, beforeVal, afterVal };
          const nextLogs = [...currentLogState, newLog];
          setSkillLog(nextLogs);
          const { pCard: np, aCard: na } = calculateValues(nextLogs);
          setPlayerCard(np); setAiCard(na);
          const nextSkills = currentAiSkills.filter(s => s.uniqueId !== bestSkill.uniqueId);
          updateAiSkills(nextSkills);
          
          const id = Date.now();
          setActiveEffects(prev => [...prev, { id, skillId: bestSkill.id, target }]); setTimeout(()=>setActiveEffects(p=>p.filter(e=>e.id!==id)), 1000);
          
          setTimeout(() => aiRespond(nextLogs, nextSkills), 1000);
        } else {
          setAiThinking(false); setMessage('Ïä§ÌÇ¨ÏùÑ ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî');
        }
      };

      const playCard = (card) => {
        if (gameState !== 'playing' || turnPhase !== 'select') return;
        originalPlayerCardRef.current = card;
        setPlayerCard(card);
        setPlayerHand(prev => prev.filter(c => c !== card));
        
        let aiSelected;
        if (forceAiCard !== null && aiHand.includes(forceAiCard)) {
          aiSelected = forceAiCard;
          setForceAiCard(null);
        } else {
          // AI Logic
          const p = aiPattern;
          let candidates = [...aiHand];
          if (p.totalMoves < 5) aiSelected = candidates[Math.floor(Math.random() * candidates.length)];
          else if (aiHand.length <= 5 && p.lateHigh > p.lateLow) {
             const lowCards = aiHand.filter(c => c <= 4);
             aiSelected = lowCards.length > 0 ? lowCards[Math.floor(Math.random() * lowCards.length)] : aiHand[Math.floor(Math.random() * aiHand.length)];
          } else {
             aiSelected = aiHand[Math.floor(Math.random() * aiHand.length)];
          }
        }

        originalAiCardRef.current = aiSelected;
        setAiCard(aiSelected);
        setAiHand(prev => prev.filter(c => c !== aiSelected));
        
        setTurnPhase('skill'); setMessage('AIÍ∞Ä ÏÉùÍ∞Å Ï§ë...'); setSkillLog([]); setAiThinking(true); setAiRetrievePending(false);
        setTimeout(() => aiRespond([], aiSkillsRef.current), 800);
      };

      const useSkill = (skill, skillIndex) => {
        if (turnPhase !== 'skill' || aiThinking) return;
        if (originalPlayerCardRef.current === null) return;
        setAiThinking(true);

        if (skill.id === 'nullify') { setNullifyMode(true); setMessage('Î¨¥Î†•ÌôîÌï† Ïä§ÌÇ¨ ÏÑ†ÌÉù'); setAiThinking(false); return; }
        if (skill.id === 'retrieve') {
           const op = originalPlayerCardRef.current; const oa = originalAiCardRef.current;
           if(op !== null) {
             setPlayerHand(prev => [...prev, op].sort((a,b)=>a-b));
             setAiHand(prev => [...prev, oa].sort((a,b)=>a-b));
             setTurnPhase('select'); setMessage('Ïπ¥ÎìúÎ•º ÌöåÏàòÌñàÏäµÎãàÎã§.'); setPlayerSkills(prev=>prev.filter((_,i)=>i!==skillIndex)); setSkillLog([]);
             const id = Date.now(); setActiveEffects(prev => [...prev, { id, skillId: 'retrieve', target: 'player' }]); setTimeout(()=>setActiveEffects(p=>p.filter(e=>e.id!==id)), 1000);
             setAiThinking(false); return;
           }
        }

        let rndVal = undefined;
        if (skill.id === 'random') rndVal = Math.floor(Math.random()*11);
        
        const target = skill.id.startsWith('opp-') ? 'ai' : 'player';
        const { pCard: prevP, aCard: prevA } = calculateValues(skillLog);
        const beforeVal = target==='player'?prevP:prevA;
        let afterVal;
        if(skill.id==='random') afterVal=rndVal;
        else {
           if(skill.id.includes('plus')) afterVal = beforeVal+1>10?0:beforeVal+1;
           else if(skill.id.includes('minus')) afterVal = beforeVal-1<0?10:beforeVal-1;
           else if(skill.id==='double') { let d=Math.floor(beforeVal)*2; afterVal=d>10?d%10:d; }
        }

        const newLog = { id: Date.now(), user: 'ÌîåÎ†àÏù¥Ïñ¥', skill, skillId: skill.id, target, nullified: false, storedValue: rndVal, beforeVal, afterVal };
        const nextLogs = [...skillLog, newLog];
        setSkillLog(nextLogs);
        if(skill.id !== 'retrieve') {
          const { pCard: np, aCard: na } = calculateValues(nextLogs);
          setPlayerCard(np); setAiCard(na);
        }
        setPlayerSkills(prev => prev.filter((_, i) => i !== skillIndex));
        const id = Date.now(); setActiveEffects(prev => [...prev, { id, skillId: skill.id, target }]); setTimeout(()=>setActiveEffects(p=>p.filter(e=>e.id!==id)), 1000);
        
        setMessage('AIÍ∞Ä ÏÉùÍ∞Å Ï§ë...');
        setTimeout(() => aiRespond(nextLogs, aiSkillsRef.current), 1000);
      };

      const nullifySkill = (logId) => {
        if (aiThinking) return;
        setAiThinking(true);
        const nullifyIdx = playerSkills.findIndex(s => s.id === 'nullify');
        if (nullifyIdx === -1) { setAiThinking(false); return; }
        
        const targetLog = skillLog.find(l => l.id === logId);
        const newLogs = skillLog.map(l => l.id === logId ? { ...l, nullified: true } : l);
        setSkillLog(newLogs);
        const { pCard: np, aCard: na } = calculateValues(newLogs);
        setPlayerCard(np); setAiCard(na);
        setPlayerSkills(prev => prev.filter((_, i) => i !== nullifyIdx));
        setNullifyMode(false); setMessage('Ïä§ÌÇ¨Ïù¥ Î¨¥Î†•ÌôîÎêòÏóàÏäµÎãàÎã§.');
        
        if(targetLog && targetLog.skillId==='retrieve' && targetLog.user==='AI') setAiRetrievePending(false);
        
        const id = Date.now(); 
        if(targetLog) { setActiveEffects(prev => [...prev, { id, skillId: 'nullify', target: targetLog.target }]); setTimeout(()=>setActiveEffects(p=>p.filter(e=>e.id!==id)), 1000); }
        
        setTimeout(() => aiRespond(newLogs, aiSkillsRef.current), 1000);
      };

      const confirmTurn = () => {
        if (aiThinking) return;
        const activeRetrieve = [...skillLog].reverse().find(l => l.skillId === 'retrieve' && !l.nullified);
        if (activeRetrieve) {
           const op = originalPlayerCardRef.current; const oa = originalAiCardRef.current;
           setPlayerHand(prev => [...prev, op].sort((a,b)=>a-b));
           setAiHand(prev => [...prev, oa].sort((a,b)=>a-b));
           setPlayerCard(null); setAiCard(null); originalPlayerCardRef.current = null; originalAiCardRef.current = null;
           setTurnPhase('select'); setMessage('ÌöåÏàòÎ°ú ÌÑ¥Ïù¥ Î¶¨ÏÖãÎêòÏóàÏäµÎãàÎã§.'); setSkillLog([]); setActiveEffects([]); setAiRetrievePending(false);
           return;
        }

        setTurnPhase('result');
        const winner = getWinner(playerCard, aiCard);
        const isTenZero = (playerCard===10 && aiCard===0) || (playerCard===0 && aiCard===10);
        
        if(winner==='player-win') { setPlayerScore(p=>p+1); setResultType('win'); setMessage(`ÏäπÎ¶¨! (${playerCard} vs ${aiCard})`); }
        else if(winner==='ai-win') { setAiScore(p=>p+1); setResultType('lose'); setMessage(`Ìå®Î∞∞! (${playerCard} vs ${aiCard})`); }
        else { setResultType('draw'); setMessage(`Î¨¥ÏäπÎ∂Ä! (${playerCard} vs ${aiCard})`); }

        if(isTenZero) {
           if(winner==='player-win') setPlayerSkills(p=>[...p, getRandomSkill(), getRandomSkill()]);
           else if(winner==='ai-win') updateAiSkills([...aiSkillsRef.current, getRandomSkill(), getRandomSkill()]);
        } else {
           const diff = Math.abs(playerCard - aiCard);
           if(diff===1 || winner==='draw') {
              if(winner!=='ai-win') setPlayerSkills(p=>[...p, getRandomSkill()]);
              if(winner!=='player-win') updateAiSkills([...aiSkillsRef.current, getRandomSkill()]);
           }
        }

        if (playerHand.length === 0) setTimeout(() => round>=MAX_ROUNDS ? setGameState('game-over') : setGameState('round-end'), 2000);
        else setTimeout(() => {
           setPlayerCard(null); setAiCard(null); originalPlayerCardRef.current=null; originalAiCardRef.current=null;
           setTurnPhase('select'); setMessage('Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî'); setSkillLog([]); setResultType(null); setActiveEffects([]);
        }, 2000);
      };

      const handleAddSkill = (skillId, target) => {
        const newSkill = createSkill(skillId);
        if(target === 'player') setPlayerSkills(prev => [...prev, newSkill]);
        else updateAiSkills([...aiSkillsRef.current, newSkill]);
      };

      return (
        <div className="w-full min-h-screen flex items-center justify-center p-0 sm:p-4 overflow-hidden relative">
          <div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'radial-gradient(circle, #ffffff 1px, transparent 1px)', backgroundSize: '20px 20px'}}></div>

          {showLeaderboard && <LeaderboardModal />}
          {showRules && <RuleModal />}
          
          {/* HIDDEN DEBUG TRIGGER */}
          <button 
            onClick={() => { if (!showDebug) { setDebugModeActive(true); setInputBuffer(""); } else setShowDebug(false); }} 
            className={`fixed bottom-2 right-2 text-gray-600 hover:text-white z-[9999] transition duration-500 ${debugModeActive ? 'opacity-100 text-yellow-600' : 'opacity-20'}`}
          >
            <Icons.Settings/>
          </button>
          <DebugConsole isOpen={showDebug} onClose={() => setShowDebug(false)} onAddSkill={handleAddSkill} onForceCard={setForceAiCard} aiHand={aiHand} nextAiCard={forceAiCard} />

          <div className="w-full max-w-5xl bg-green-900/90 backdrop-blur-sm sm:rounded-3xl shadow-2xl border-x-0 sm:border border-green-700 overflow-hidden flex flex-col lg:flex-row h-screen sm:h-auto sm:min-h-[650px]">
            {/* Left Panel */}
            <div className="flex-1 flex flex-col relative overflow-y-auto">
              {/* AI Header */}
              <div className="bg-black/30 p-2 sm:p-3 flex justify-between items-center border-b border-white/10 shrink-0">
                <div className="flex flex-col">
                  <div className="flex items-center gap-2">
                    <span className="text-red-300 font-bold text-sm">AI OPPONENT</span>
                    {aiThinking && <span className="text-yellow-400 text-xs animate-thinking">ü§î ÏÉùÍ∞Å Ï§ë...</span>}
                  </div>
                  <span className="text-xs text-gray-400">Lv. Aggressive</span>
                </div>
                <div className="flex items-center gap-3">
                  <button onClick={() => setShowAiSkills(!showAiSkills)} className={`p-1.5 rounded-full transition-colors ${showAiSkills ? 'bg-yellow-500 text-black' : 'bg-gray-700 text-gray-400 hover:text-white'}`}>
                    {showAiSkills ? <Icons.Eye /> : <Icons.EyeOff />}
                  </button>
                  <div className="text-2xl font-bold text-white font-mono">{aiScore}</div>
                </div>
              </div>

              {/* AI Field */}
              <div className="flex-1 flex flex-col items-center justify-center p-2 gap-4 min-h-[200px]">
                <div className={`flex flex-wrap justify-center gap-1.5 transition-all duration-300 ${showAiSkills ? 'min-h-[60px]' : 'h-8'}`}>
                  {aiSkills.map((skill) => (
                    showAiSkills ? (
                      <div key={skill.uniqueId} className={`px-2 py-1 ${skill.color} rounded flex items-center gap-1 text-[10px] text-white shadow-md animate-pop`}><SkillIcon iconName={skill.icon} /><span>{skill.name}</span></div>
                    ) : (
                      <div key={skill.uniqueId} className={`w-5 h-5 rounded ${skill.color} flex items-center justify-center shadow-sm`}><span className="text-[8px] text-white">‚ö°</span></div>
                    )
                  ))}
                  {aiSkills.length === 0 && <span className="text-xs text-gray-500 self-center">No Skills</span>}
                </div>
                <div className="flex items-center gap-8 relative">
                   <div className="relative">
                     <div className="absolute -top-6 w-full text-center text-xs text-gray-400">HAND: {aiHand.length}</div>
                     {aiCard !== null ? <Card number={aiCard} isHidden={turnPhase === 'select' && !resultType} /> : <div className="w-14 h-20 sm:w-16 sm:h-24 border-2 border-dashed border-white/20 rounded-lg flex items-center justify-center text-white/20">Empty</div>}
                     <EffectLayer activeEffects={activeEffects} target="ai" />
                   </div>
                </div>
              </div>

              {/* Message */}
              <div className={`py-2 text-center transition-colors duration-300 shrink-0 ${resultType === 'win' ? 'bg-blue-600/50' : resultType === 'lose' ? 'bg-red-600/50' : 'bg-black/20'}`}>
                <h2 className="text-yellow-400 font-bold text-xs uppercase tracking-widest mb-1">Round {round} / {MAX_ROUNDS}</h2>
                <div className="text-lg sm:text-xl text-white font-bold drop-shadow-md animate-pop px-2">{message}</div>
                {turnPhase === 'skill' && (
                  <button onClick={confirmTurn} disabled={aiThinking} className={`mt-2 px-6 py-2 font-bold rounded-full text-sm shadow-lg transition-all ${aiThinking ? 'bg-gray-500 text-gray-300 cursor-not-allowed' : 'bg-yellow-500 active:bg-yellow-600 text-black active:scale-95'}`}>
                    {aiThinking ? 'AI ÏÉùÍ∞Å Ï§ë...' : 'Í≤∞Í≥º ÌôïÏù∏ (Turn End)'}
                  </button>
                )}
              </div>

              {/* Player Field */}
              <div className="flex-1 flex flex-col items-center justify-start p-2 sm:p-4 gap-3 bg-black/10">
                 <div className="flex justify-center relative">
                    {playerCard !== null ? <Card number={playerCard} isSelected={true} /> : <div className="w-14 h-20 sm:w-16 sm:h-24 border-2 border-dashed border-blue-400/30 rounded-lg flex items-center justify-center text-blue-200/30 text-sm">Select</div>}
                    <EffectLayer activeEffects={activeEffects} target="player" />
                 </div>
                 <div className="flex flex-wrap justify-center gap-2 min-h-[32px]">
                    {playerSkills.map((skill, i) => <SkillBadge key={skill.uniqueId} skill={skill} onClick={() => useSkill(skill, i)} disabled={turnPhase !== 'skill' || aiThinking} />)}
                 </div>
                 <div className="w-full flex justify-center gap-2 flex-wrap pb-2">
                   {playerHand.map((card, i) => <Card key={`${card}-${i}`} number={card} onClick={() => playCard(card)} disabled={turnPhase !== 'select'} />)}
                 </div>
              </div>

              <div className="bg-black/30 p-2 sm:p-3 flex justify-between items-center border-t border-white/10 shrink-0">
                <div className="flex flex-col"><span className="text-blue-300 font-bold text-sm">PLAYER</span><span className="text-xs text-gray-400">10 beats 0 ‚Üí +2 Skills</span></div>
                <div className="text-2xl font-bold text-white font-mono">{playerScore}</div>
              </div>
            </div>

            {/* Right Panel */}
            <div className="w-full lg:w-64 bg-black/40 border-t lg:border-t-0 lg:border-l border-white/10 p-4 flex flex-col max-h-48 lg:max-h-none shrink-0">
              <h3 className="text-yellow-500 font-bold text-xs uppercase tracking-wider mb-2 sticky top-0 flex justify-between items-center">
                <span>Battle Log</span>
                <span className="text-[10px] text-gray-400">{APP_VERSION}</span>
              </h3>
              {nullifyMode && <span className="text-red-500 animate-blink text-xs mb-1 block">(Select Target)</span>}
              <div className="flex-1 overflow-y-auto custom-scroll space-y-2 pr-1">
                {skillLog.map((log) => (
                  <div key={log.id} onClick={() => nullifyMode && !log.nullified && !aiThinking && nullifySkill(log.id)} className={`p-2 rounded text-xs text-white ${log.nullified ? 'bg-gray-800 opacity-50' : log.skill.color} ${nullifyMode && !log.nullified && !aiThinking ? 'cursor-pointer animate-shake ring-2 ring-white' : ''}`}>
                    <div className="flex justify-between"><strong>{log.user}</strong>{log.nullified && <span className="text-red-300 line-through">Î¨¥Ìö®Îê®</span>}</div>
                    <div className="flex items-center gap-1"><span>{log.skill.name}</span><span className="opacity-75 text-[10px]">‚Üí {log.target === 'player' ? 'ÎÇò' : 'ÏÉÅÎåÄ'}</span></div>
                    {!log.nullified && log.beforeVal !== undefined && (<div className="text-[10px] font-mono mt-1 bg-black/20 px-1 rounded inline-block">{log.beforeVal} ‚Üí <span className="font-bold text-yellow-200">{log.afterVal}</span></div>)}
                  </div>
                ))}
              </div>
              {nullifyMode && <button onClick={() => { setNullifyMode(false); setAiThinking(false); }} className="mt-2 w-full py-3 bg-gray-600 text-white text-xs rounded-lg active:scale-95">Ï∑®ÏÜå</button>}
            </div>

            {/* Overlay Screens */}
            {gameState === 'start' && (
              <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6 text-center">
                <h1 className="text-5xl md:text-7xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-yellow-600 mb-6">ZERO POINT</h1>
                <div className="flex flex-col sm:flex-row gap-4"><button onClick={resetCampaign} className="px-8 py-4 bg-yellow-500 font-bold rounded-full shadow-lg hover:scale-105 transition">START GAME</button><button onClick={() => setShowLeaderboard(true)} className="px-6 py-4 bg-gray-700 text-white font-bold rounded-full">RANKING</button><button onClick={() => setShowRules(true)} className="px-6 py-4 bg-green-700 text-white font-bold rounded-full">üìñ ÏÑ§Î™Ö</button></div>
              </div>
            )}
            {gameState === 'round-end' && (
              <div className="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center animate-pop p-4 text-center">
                <h2 className="text-3xl font-bold text-white mb-4">ROUND {round} COMPLETE</h2>
                <div className="text-2xl text-white mb-8 font-mono border p-4 rounded-lg">Player {playerScore} : {aiScore} AI</div>
                <button onClick={() => { setRound(r=>r+1); grantRoundSkills(round+1); initGame(); }} className="w-full max-w-xs px-8 py-4 bg-blue-600 text-white font-bold rounded-lg">Next Round</button>
              </div>
            )}
            {gameState === 'game-over' && (
              <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6 animate-pop text-center">
                <h2 className="text-4xl font-bold text-yellow-400 mb-2">GAME FINISHED</h2>
                <div className="text-6xl font-black text-white mb-8">{playerScore}</div>
                <input type="text" maxLength="8" placeholder="Ïù¥Î¶Ñ ÏûÖÎ†•" className="w-full px-4 py-3 rounded-lg bg-gray-800 text-white text-center mb-2" value={playerName} onChange={(e) => setPlayerName(e.target.value)} />
                <button onClick={submitScore} disabled={isSubmitting} className="w-full py-4 bg-green-600 text-white font-bold rounded-lg">{isSubmitting ? 'Ï†ÄÏû• Ï§ë...' : 'Ï†êÏàò Ï†ÄÏû•'}</button>
                <button onClick={() => setGameState('start')} className="w-full py-3 text-gray-400">Î©îÏù∏ÏúºÎ°ú</button>
              </div>
            )}
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ZeroPointGame />);
  </script>
</body>
</html>
